# Generated by Django 2.1.7 on 2019-03-28 19:59
import logging

from django.db import migrations, transaction
from django.contrib.postgres.operations import CITextExtension


LOG = logging.getLogger(name=__name__)


class Migration(migrations.Migration):

    dependencies = [
        ('beers', '0017_untappdmetadata'),
    ]

    def merge_case_matching_beers(apps, schema_editor):
        beer_model = apps.get_model('beers.Beer')
        beers = beer_model.objects.all().prefetch_related('taps').select_related(
            'manufacturer'
        )
        if not beers.exists():
            return
        beer_dict = {}
        for beer in beers:
            try:
                beer_dict[(beer.manufacturer_id, beer.name.casefold())].append(
                    beer
                )
            except KeyError:
                beer_dict[(beer.manufacturer_id, beer.name.casefold())] = [
                    beer
                ]
        for (mfg_pk, ci_name), beer_list in beer_dict.items():
            if len(beer_list) == 1:
                # no duplicate!
                continue
            # sort the beer list by number of occupied taps for simplicity
            beer_list = sorted(
                beer_list, key=lambda beer: len(beer.taps.all()), reverse=True)
            kept = beer_list[0]
            for beer in beer_list[1:]:
                print('merging %s into %s' % (beer.name, kept.name))
                merge_beer(kept, beer)

    def merge_case_matching_mfgs(apps, schema_editor):
        mfg_model = apps.get_model('beers.Manufacturer')
        mfgs = mfg_model.objects.all().prefetch_related('beers')
        if not mfgs.exists():
            return
        mfg_dict = {}
        for mfg in mfgs:
            try:
                mfg_dict[mfg.name.casefold()].append(mfg)
            except KeyError:
                mfg_dict[mfg.name.casefold()] = [mfg]
        for ci_name, mfg_list in mfg_dict.items():
            if len(mfg_list) == 1:
                # no duplicate!
                continue
            # sort the beer list by number of beers for simplicity
            mfg_list = sorted(
                mfg_list, key=lambda mfg: len(mfg.beers.all()), reverse=True)
            kept = mfg_list[0]
            for mfg in mfg_list[1:]:
                print('merging mfg %s into %s' % (mfg.name, kept.name))
                merge_mfg(kept, mfg)

    operations = [
        # 1. enable case-insensitive extension
        CITextExtension(),
        migrations.RunPython(
            merge_case_matching_beers, migrations.RunPython.noop,
        ),
        migrations.RunPython(
            merge_case_matching_mfgs, migrations.RunPython.noop,
        ),
    ]


def merge_beer(kept_beer, other):
    LOG.info('merging %s into %s', other, kept_beer)
    with transaction.atomic():
        for tap in other.taps.all():
            tap.beer = kept_beer
            tap.save()
        for alternate_name in other.alternate_names.all():
            alternate_name.beer = kept_beer
            alternate_name.save()
        excluded_fields = {
            'name' 'in_production', 'automatic_updates_blocked',
            'manufacturer', 'id',
        }
        for field in kept_beer._meta.fields:
            field_name = field.name
            if field_name in excluded_fields:
                continue
            other_value = getattr(other, field_name)
            if getattr(kept_beer, field_name) or not other_value:
                # don't overwrite data that's already there
                # or isn't set in the other one
                continue
            setattr(kept_beer, field_name, other_value)
        kept_beer.automatic_updates_blocked = True
        if other.name.casefold() != kept_beer.name.casefold():
            # this will only not happen if manufacturers aren't the same
            BeerAlternateName.objects.update_or_create(
                name=other.name,
                beer=kept_beer,
            )
        other.delete()
        kept_beer.save()


def merge_mfg(kept, other):
    LOG.info('merging %s into %s', other, kept)
    with transaction.atomic():
        other_beers = list(other.beers.all())
        my_beers = {i.name.casefold(): i for i in kept.beers.all()}
        for beer in other_beers:
            beer.manufacturer = kept
            if beer.name.casefold() in my_beers:
                # we have a duplicate beer. Merge those two first.
                # merge_from takes care of saving my_beer and deleting
                # beer
                # keep the one that was already present
                my_beer = my_beers[beer.name.casefold()]
                merge_beer(my_beer, beer)
            else:
                # good
                beer.save()

        excluded_fields = {
            'name', 'automatic_updates_blocked', 'id',
        }
        for field in kept._meta.fields:
            field_name = field.name
            if field_name in excluded_fields:
                continue
            other_value = getattr(other, field_name)
            if getattr(kept, field_name) or not other_value:
                # don't overwrite data that's already there
                # or isn't set in the other one
                continue
            setattr(kept, field_name, other_value)
        kept.automatic_updates_blocked = True
        other.delete()
        kept.save()
