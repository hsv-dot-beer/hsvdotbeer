# Generated by Django 2.1.7 on 2019-03-28 19:59
import logging

from django.db import migrations, transaction
from django.contrib.postgres.operations import CITextExtension


LOG = logging.getLogger(name=__name__)


class Migration(migrations.Migration):

    dependencies = [
        ("beers", "0017_untappdmetadata"),
    ]

    def merge_case_matching_beers(apps, schema_editor):
        beer_model = apps.get_model("beers.Beer")
        beers = (
            beer_model.objects.all()
            .prefetch_related("taps")
            .select_related("manufacturer")
        )
        if not beers.exists():
            return
        beer_dict = {}
        for beer in beers:
            try:
                beer_dict[(beer.manufacturer_id, beer.name.casefold())].append(beer)
            except KeyError:
                beer_dict[(beer.manufacturer_id, beer.name.casefold())] = [beer]
        for (mfg_pk, ci_name), beer_list in beer_dict.items():
            if len(beer_list) == 1:
                # no duplicate!
                continue
            # sort the beer list by number of occupied taps for simplicity
            beer_list = sorted(
                beer_list, key=lambda beer: len(beer.taps.all()), reverse=True
            )
            kept = beer_list[0]
            for beer in beer_list[1:]:
                print("merging %s into %s" % (beer.name, kept.name))
                merge_beer(kept, beer)

    def merge_case_matching_mfgs(apps, schema_editor):
        mfg_model = apps.get_model("beers.Manufacturer")
        mfgs = mfg_model.objects.all().prefetch_related("beers")
        if not mfgs.exists():
            return
        mfg_dict = {}
        for mfg in mfgs:
            try:
                mfg_dict[mfg.name.casefold()].append(mfg)
            except KeyError:
                mfg_dict[mfg.name.casefold()] = [mfg]
        for ci_name, mfg_list in mfg_dict.items():
            if len(mfg_list) == 1:
                # no duplicate!
                continue
            # sort the beer list by number of beers for simplicity
            mfg_list = sorted(
                mfg_list, key=lambda mfg: len(mfg.beers.all()), reverse=True
            )
            kept = mfg_list[0]
            for mfg in mfg_list[1:]:
                print("merging mfg %s into %s" % (mfg.name, kept.name))
                merge_mfg(kept, mfg)

    operations = [
        # 1. enable case-insensitive extension
        CITextExtension(),
        migrations.RunPython(
            merge_case_matching_beers,
            migrations.RunPython.noop,
        ),
        migrations.RunPython(
            merge_case_matching_mfgs,
            migrations.RunPython.noop,
        ),
    ]


def merge_beer(kept_beer, other):
    LOG.info("merging %s into %s", other, kept_beer)
    with transaction.atomic():
        for tap in other.taps.all():
            tap.beer = kept_beer
            tap.save()
        for alternate_name in other.alternate_names.all():
            alternate_name.beer = kept_beer
            alternate_name.save()
        excluded_fields = {
            "name" "in_production",
            "automatic_updates_blocked",
            "manufacturer",
            "id",
        }
        for field in kept_beer._meta.fields:
            field_name = field.name
            if field_name in excluded_fields:
                continue
            other_value = getattr(other, field_name)
            if getattr(kept_beer, field_name) or not other_value:
                # don't overwrite data that's already there
                # or isn't set in the other one
                continue
            setattr(kept_beer, field_name, other_value)
        kept_beer.automatic_updates_blocked = True
        if other.name.casefold() != kept_beer.name.casefold():
            # this will only not happen if manufacturers aren't the same
            BeerAlternateName.objects.update_or_create(
                name=other.name,
                beer=kept_beer,
            )
        other.delete()
        kept_beer.save()


def merge_mfg(kept, other):
    LOG.info("merging %s into %s", other, kept)
    with transaction.atomic():
        other_beers = list(other.beers.all())
        my_beers = {i.name.casefold(): i for i in kept.beers.all()}
        for beer in other_beers:
            beer.manufacturer = kept
            if beer.name.casefold() in my_beers:
                # we have a duplicate beer. Merge those two first.
                # merge_from takes care of saving my_beer and deleting
                # beer
                # keep the one that was already present
                my_beer = my_beers[beer.name.casefold()]
                merge_beer(my_beer, beer)
            else:
                # good
                beer.save()

        excluded_fields = {
            "name",
            "automatic_updates_blocked",
            "id",
        }
        for field in kept._meta.fields:
            field_name = field.name
            if field_name in excluded_fields:
                continue
            other_value = getattr(other, field_name)
            if getattr(kept, field_name) or not other_value:
                # don't overwrite data that's already there
                # or isn't set in the other one
                continue
            setattr(kept, field_name, other_value)
        kept.automatic_updates_blocked = True
        other.delete()
        kept.save()
